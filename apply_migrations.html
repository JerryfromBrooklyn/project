<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apply Database Migrations</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    #output {
      background-color: #f4f4f4;
      border-radius: 5px;
      padding: 15px;
      white-space: pre-wrap;
      font-family: monospace;
      height: 400px;
      overflow-y: auto;
      margin-top: 20px;
    }
    .success { color: green; }
    .error { color: red; }
    button {
      background-color: #1E90FF;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }
    button:hover {
      background-color: #0066CC;
    }
    textarea {
      width: 100%;
      height: 200px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Photo Upload Fixes - Database Migrations</h1>
  
  <div>
    <p>Enter your Supabase URL and API key to run the migrations:</p>
    <input id="supabaseUrl" type="text" placeholder="Supabase URL" style="width: 100%; margin-bottom: 10px; padding: 8px;">
    <input id="supabaseKey" type="password" placeholder="Supabase API Key" style="width: 100%; margin-bottom: 10px; padding: 8px;">
    
    <h3>Step 1: Disable RLS and Update Photo Functions</h3>
    <button id="runMigration1">Run Migration #1</button>
    
    <h3>Step 2: Add Photo Verification Function</h3>
    <button id="runMigration2">Run Migration #2</button>
    
    <h3>Step 3: Add Photo Search Function</h3>
    <button id="runMigration3">Run Migration #3</button>
    
    <h3>Run Custom SQL</h3>
    <textarea id="customSql" placeholder="Enter custom SQL to run"></textarea>
    <button id="runCustomSql">Execute Custom SQL</button>
  </div>
  
  <div id="output">Ready to run migrations...</div>
  
  <script>
    // Migration SQL scripts
    const migrations = {
      migration1: `
-- Fix photo upload issues by:
-- 1. Disabling RLS on photos and simple_photos tables
-- 2. Creating a new function that works reliably
-- 3. Setting proper default values for JSON fields

-- Disable RLS on all photo-related tables
ALTER TABLE IF EXISTS public.photos DISABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.simple_photos DISABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.photo_faces DISABLE ROW LEVEL SECURITY;

-- Drop the current function if it exists
DROP FUNCTION IF EXISTS public.complete_photo_insert;

-- Create a more robust version of the function that targets both tables
CREATE OR REPLACE FUNCTION public.complete_photo_insert(
    p_id UUID,
    p_user_id UUID,
    p_storage_path TEXT,
    p_public_url TEXT,
    p_file_size BIGINT,
    p_file_type TEXT,
    p_faces JSONB DEFAULT '[]'::JSONB,
    p_face_ids TEXT[] DEFAULT '{}'::TEXT[],
    p_matched_users JSONB DEFAULT '[]'::JSONB,
    p_metadata JSONB DEFAULT '{}'::JSONB
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_id UUID;
    location_data JSONB;
    venue_data JSONB;
    event_details_data JSONB;
    tags_data TEXT[];
    title_data TEXT;
    date_taken_data TIMESTAMPTZ;
BEGIN
    -- Extract metadata fields with proper null handling
    location_data := COALESCE(p_metadata->'location', '{"lat": null, "lng": null, "name": null}'::JSONB);
    venue_data := COALESCE(p_metadata->'venue', '{"id": null, "name": null}'::JSONB);
    event_details_data := COALESCE(p_metadata->'event_details', '{"date": null, "name": null, "type": null}'::JSONB);
    
    -- Extract array data with proper handling
    BEGIN
        -- Try to convert tags from JSONB to text array
        SELECT array_agg(x::TEXT)
        FROM jsonb_array_elements_text(p_metadata->'tags')
        INTO tags_data;
    EXCEPTION WHEN OTHERS THEN
        tags_data := '{}'::TEXT[];
    END;
    
    -- Handle other metadata
    title_data := p_metadata->>'title';
    
    -- Handle date with proper format if provided
    IF p_metadata->>'date_taken' IS NOT NULL AND p_metadata->>'date_taken' != '' THEN
        BEGIN
            date_taken_data := (p_metadata->>'date_taken')::TIMESTAMPTZ;
        EXCEPTION WHEN OTHERS THEN
            date_taken_data := NOW();
        END;
    ELSE
        date_taken_data := NOW();
    END IF;

    -- Try to insert into photos table first
    BEGIN
        INSERT INTO public.photos (
            id,
            uploaded_by,
            user_id,
            storage_path,
            public_url,
            url,
            file_size,
            size,
            file_type,
            type,
            faces,
            matched_users,
            face_ids,
            location,
            venue,
            event_details,
            tags,
            title,
            date_taken,
            created_at,
            updated_at
        ) VALUES (
            p_id,
            p_user_id,
            p_user_id,
            p_storage_path,
            p_public_url,
            p_public_url,
            p_file_size,
            p_file_size,
            p_file_type,
            p_file_type,
            p_faces,
            p_matched_users,
            p_face_ids,
            location_data,
            venue_data,
            event_details_data,
            COALESCE(tags_data, '{}'::TEXT[]),
            title_data,
            date_taken_data,
            NOW(),
            NOW()
        )
        RETURNING id INTO v_id;
    EXCEPTION WHEN OTHERS THEN
        RAISE NOTICE 'Error inserting into photos: %', SQLERRM;
        -- If insertion into photos fails, try simple_photos as fallback
        BEGIN
            INSERT INTO public.simple_photos (
                id,
                uploaded_by,
                storage_path,
                public_url,
                file_size,
                file_type,
                faces,
                matched_users,
                face_ids,
                location,
                venue,
                event_details,
                tags,
                title,
                date_taken,
                created_at,
                updated_at
            ) VALUES (
                p_id,
                p_user_id,
                p_storage_path,
                p_public_url,
                p_file_size,
                p_file_type,
                p_faces,
                p_matched_users,
                p_face_ids,
                location_data,
                venue_data,
                event_details_data,
                COALESCE(tags_data, '{}'::TEXT[]),
                title_data,
                date_taken_data,
                NOW(),
                NOW()
            )
            RETURNING id INTO v_id;
        EXCEPTION WHEN OTHERS THEN
            RAISE NOTICE 'Error inserting into simple_photos: %', SQLERRM;
            -- Return the ID even if both inserts fail - at least the file is in storage
            v_id := p_id;
        END;
    END;
    
    -- Process any matched user faces by adding to photo_faces
    IF jsonb_array_length(p_matched_users) > 0 THEN
        FOR i IN 0..jsonb_array_length(p_matched_users)-1 LOOP
            DECLARE
                v_match JSONB := p_matched_users->i;
                v_user_id UUID;
                v_confidence FLOAT;
                v_face_id TEXT;
            BEGIN
                -- Extract user ID and confidence
                v_user_id := (v_match->>'userId')::UUID;
                v_confidence := COALESCE((v_match->>'confidence')::FLOAT, 95.0);
                v_face_id := COALESCE(v_match->>'faceId', 'matched-by-aws');
                
                IF v_user_id IS NOT NULL THEN
                    -- Create/update photo_faces entry
                    INSERT INTO photo_faces (
                        photo_id,
                        user_id,
                        face_id,
                        confidence
                    ) VALUES (
                        p_id,
                        v_user_id,
                        v_face_id,
                        v_confidence
                    )
                    ON CONFLICT (photo_id, user_id) 
                    DO UPDATE SET 
                        confidence = v_confidence,
                        updated_at = NOW();
                END IF;
            EXCEPTION WHEN OTHERS THEN
                RAISE NOTICE 'Error processing matched user: %', SQLERRM;
                -- Continue with the next user
            END;
        END LOOP;
    END IF;

    -- Return the photo ID
    RETURN p_id;
END;
$$;

-- Create a view that combines both tables to make retrieval more reliable
CREATE OR REPLACE VIEW public.all_photos AS
SELECT 
    p.id,
    p.uploaded_by,
    p.user_id,
    p.storage_path,
    p.public_url,
    p.url,
    p.folder_path,
    p.folder_name,
    p.file_size,
    p.size,
    p.file_type,
    p.type,
    p.event_id,
    p.faces,
    p.matched_users,
    p.face_ids,
    p.title,
    p.description,
    p.location,
    p.venue,
    p.tags,
    p.date_taken,
    p.event_details,
    p.created_at,
    p.updated_at,
    p.resolution,
    'photos' AS source_table
FROM 
    public.photos p
UNION ALL
SELECT 
    s.id,
    s.uploaded_by,
    s.uploaded_by AS user_id, -- Use uploaded_by as user_id
    s.storage_path,
    s.public_url,
    s.public_url AS url, -- Use public_url as url
    s.folder_path,
    s.folder_name,
    s.file_size,
    s.file_size AS size, -- Use file_size as size
    s.file_type,
    s.file_type AS type, -- Use file_type as type
    s.event_id,
    s.faces,
    s.matched_users,
    s.face_ids,
    s.title,
    s.description,
    s.location,
    s.venue,
    s.tags,
    s.date_taken,
    s.event_details,
    s.created_at,
    s.updated_at,
    NULL AS resolution,
    'simple_photos' AS source_table
FROM 
    public.simple_photos s;

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION public.complete_photo_insert TO authenticated;
GRANT EXECUTE ON FUNCTION public.complete_photo_insert TO anon;
GRANT EXECUTE ON FUNCTION public.complete_photo_insert TO service_role;

-- Grant select permissions on the view
GRANT SELECT ON public.all_photos TO authenticated;
GRANT SELECT ON public.all_photos TO anon;
GRANT SELECT ON public.all_photos TO service_role;`,
      
      migration2: `
-- Create a reliable photo verification function that queries both tables
-- This will help fix the 406 Not Acceptable errors when verifying photos

CREATE OR REPLACE FUNCTION public.verify_photo_exists(p_photo_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    photo_data JSONB := NULL;
    photo_exists BOOLEAN := FALSE;
    source_table TEXT := '';
BEGIN
    -- Try photos table first
    SELECT EXISTS(
        SELECT 1 FROM public.photos WHERE id = p_photo_id
    ) INTO photo_exists;
    
    IF photo_exists THEN
        source_table := 'photos';
        SELECT
            jsonb_build_object(
                'id', p.id,
                'uploaded_by', p.uploaded_by,
                'user_id', p.user_id,
                'storage_path', p.storage_path,
                'public_url', p.public_url,
                'url', p.url,
                'file_size', p.file_size,
                'file_type', p.file_type,
                'faces', p.faces,
                'matched_users', p.matched_users,
                'face_ids', p.face_ids,
                'location', p.location,
                'venue', p.venue,
                'event_details', p.event_details,
                'tags', p.tags,
                'title', p.title,
                'date_taken', p.date_taken,
                'created_at', p.created_at,
                'source_table', source_table
            )
        INTO photo_data
        FROM public.photos p
        WHERE p.id = p_photo_id;
        
        RETURN photo_data;
    END IF;
    
    -- If not in photos, try simple_photos
    SELECT EXISTS(
        SELECT 1 FROM public.simple_photos WHERE id = p_photo_id
    ) INTO photo_exists;
    
    IF photo_exists THEN
        source_table := 'simple_photos';
        SELECT
            jsonb_build_object(
                'id', s.id,
                'uploaded_by', s.uploaded_by,
                'user_id', s.uploaded_by,
                'storage_path', s.storage_path,
                'public_url', s.public_url,
                'url', s.public_url,
                'file_size', s.file_size,
                'file_type', s.file_type,
                'faces', s.faces,
                'matched_users', s.matched_users,
                'face_ids', s.face_ids,
                'location', s.location,
                'venue', s.venue,
                'event_details', s.event_details,
                'tags', s.tags,
                'title', s.title,
                'date_taken', s.date_taken,
                'created_at', s.created_at,
                'source_table', source_table
            )
        INTO photo_data
        FROM public.simple_photos s
        WHERE s.id = p_photo_id;
        
        RETURN photo_data;
    END IF;
    
    -- If photo not found in either table
    RETURN jsonb_build_object(
        'id', p_photo_id,
        'exists', FALSE,
        'source_table', 'none'
    );
END;
$$;

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION public.verify_photo_exists TO authenticated;
GRANT EXECUTE ON FUNCTION public.verify_photo_exists TO anon;
GRANT EXECUTE ON FUNCTION public.verify_photo_exists TO service_role;`,
      
      migration3: `
-- Create a reliable function for searching photos that match a specific user
-- This handles the JSONB matching correctly against both photos and simple_photos tables

CREATE OR REPLACE FUNCTION public.search_photos_for_user(user_id UUID)
RETURNS SETOF JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    matched_photos JSONB[];
    photo_record RECORD;
BEGIN
    -- First, search the photos table
    FOR photo_record IN (
        SELECT *
        FROM public.photos
        WHERE 
            -- Check if this user ID appears in the matched_users array
            EXISTS (
                SELECT 1
                FROM jsonb_array_elements(matched_users) as elem
                WHERE elem->>'userId' = user_id::TEXT
            )
        ORDER BY created_at DESC
    ) LOOP
        matched_photos := array_append(
            matched_photos, 
            to_jsonb(photo_record)
        );
    END LOOP;
    
    -- Next, search the simple_photos table
    FOR photo_record IN (
        SELECT *
        FROM public.simple_photos
        WHERE 
            -- Check if this user ID appears in the matched_users array
            EXISTS (
                SELECT 1
                FROM jsonb_array_elements(matched_users) as elem
                WHERE elem->>'userId' = user_id::TEXT
            )
        ORDER BY created_at DESC
    ) LOOP
        -- Skip duplicates (photos that might be in both tables)
        IF NOT EXISTS (
            SELECT 1
            FROM unnest(matched_photos) as mp
            WHERE mp->>'id' = photo_record.id::TEXT
        ) THEN
            matched_photos := array_append(
                matched_photos, 
                to_jsonb(photo_record)
            );
        END IF;
    END LOOP;
    
    -- Return results
    IF array_length(matched_photos, 1) > 0 THEN
        RETURN QUERY 
        SELECT unnest(matched_photos);
    END IF;
    
    RETURN;
END;
$$;

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION public.search_photos_for_user TO authenticated;
GRANT EXECUTE ON FUNCTION public.search_photos_for_user TO anon;
GRANT EXECUTE ON FUNCTION public.search_photos_for_user TO service_role;`
    };
    
    // Initialize output
    const output = document.getElementById('output');
    
    function log(message, type = 'normal') {
      const span = document.createElement('span');
      span.className = type;
      span.textContent = message + '\n';
      output.appendChild(span);
      output.scrollTop = output.scrollHeight;
    }
    
    // Initialize Supabase client
    function initSupabase() {
      const url = document.getElementById('supabaseUrl').value;
      const key = document.getElementById('supabaseKey').value;
      
      if (!url || !key) {
        log('Please enter Supabase URL and API key', 'error');
        return null;
      }
      
      return supabase.createClient(url, key);
    }
    
    async function runSql(sql) {
      const client = initSupabase();
      if (!client) return;
      
      try {
        log('Running SQL...');
        const { data, error } = await client.rpc('admin_exec_sql', { sql });
        
        if (error) {
          log('Error: ' + error.message, 'error');
          return false;
        }
        
        log('SQL executed successfully!', 'success');
        log('Result: ' + JSON.stringify(data));
        return true;
      } catch (err) {
        log('Error: ' + err.message, 'error');
        return false;
      }
    }
    
    // Event listeners
    document.getElementById('runMigration1').addEventListener('click', async () => {
      await runSql(migrations.migration1);
    });
    
    document.getElementById('runMigration2').addEventListener('click', async () => {
      await runSql(migrations.migration2);
    });
    
    document.getElementById('runMigration3').addEventListener('click', async () => {
      await runSql(migrations.migration3);
    });
    
    document.getElementById('runCustomSql').addEventListener('click', async () => {
      const sql = document.getElementById('customSql').value;
      if (!sql) {
        log('Please enter SQL to execute', 'error');
        return;
      }
      await runSql(sql);
    });
  </script>
</body>
</html> 